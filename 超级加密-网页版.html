<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å…¨å­—ç¬¦åŠ å¯†ç³»ç»Ÿ - æœ€é«˜é˜²å¾¡çº§åˆ«</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        
        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 16px;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
            width: 100%;
            max-width: 1200px;
            overflow: hidden;
            backdrop-filter: blur(10px);
        }
        
        .header {
            background: linear-gradient(135deg, #4a6ee0 0%, #6a3dba 100%);
            color: white;
            padding: 24px 32px;
            position: relative;
            cursor: pointer;
            user-select: none;
        }
        
        .header h1 {
            font-size: 28px;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .header p {
            opacity: 0.9;
            font-size: 16px;
        }
        
        .content {
            padding: 32px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
        }
        
        .panel {
            display: flex;
            flex-direction: column;
        }
        
        .panel h2 {
            color: #444;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 2px solid #f0f0f0;
            font-weight: 600;
            display: flex;
            align-items: center;
        }
        
        .panel h2 .icon {
            margin-right: 8px;
            font-size: 20px;
        }
        
        textarea {
            flex: 1;
            padding: 16px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 16px;
            resize: none;
            transition: all 0.3s;
            line-height: 1.5;
        }
        
        textarea:focus {
            outline: none;
            border-color: #4a6ee0;
            box-shadow: 0 0 0 2px rgba(74, 110, 224, 0.2);
        }
        
        .input-panel textarea {
            min-height: 200px;
        }
        
        .output-panel textarea {
            min-height: 200px;
            background: #f8f9fa;
        }
        
        .settings {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .setting-group {
            display: flex;
            flex-direction: column;
        }
        
        label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #444;
            font-size: 14px;
            display: flex;
            align-items: center;
        }
        
        label .icon {
            margin-right: 6px;
            font-size: 16px;
        }
        
        select, input {
            padding: 12px 16px;
            border: 1px solid #ddd;
            border-radius: 8px;
            font-size: 15px;
            transition: all 0.3s;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: #4a6ee0;
            box-shadow: 0 0 0 2px rgba(74, 110, 224, 0.2);
        }
        
        .super-encryption {
            background: linear-gradient(135deg, #8e2de2, #4a00e0);
            color: white;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            grid-column: 1 / -1;
        }
        
        .super-encryption h3 {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }
        
        .super-encryption h3 .icon {
            margin-right: 8px;
        }
        
        .super-controls {
            display: flex;
            gap: 10px;
        }
        
        .super-controls button {
            flex: 1;
        }
        
        .master-mode {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            grid-column: 1 / -1;
        }
        
        .master-mode h3 {
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }
        
        .master-mode h3 .icon {
            margin-right: 8px;
        }
        
        .master-controls {
            display: flex;
            gap: 10px;
        }
        
        .master-controls button {
            flex: 1;
        }
        
        .index-code {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            grid-column: 1 / -1;
        }
        
        .index-code h3 {
            color: #444;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }
        
        .index-code h3 .icon {
            margin-right: 8px;
        }
        
        .index-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .index-controls button {
            flex: 1;
        }
        
        .charset-editor {
            background: #f8f9fa;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            grid-column: 1 / -1;
            display: none;
        }
        
        .charset-editor h3 {
            color: #444;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
        }
        
        .charset-editor h3 .icon {
            margin-right: 8px;
        }
        
        .charset-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .charset-controls button {
            flex: 1;
        }
        
        .controls {
            display: flex;
            gap: 12px;
            margin-top: 20px;
        }
        
        button {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .primary-btn {
            background: linear-gradient(135deg, #4a6ee0 0%, #6a3dba 100%);
            color: white;
            flex: 1;
        }
        
        .primary-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(74, 110, 224, 0.4);
        }
        
        .secondary-btn {
            background: #f0f2f5;
            color: #444;
        }
        
        .secondary-btn:hover {
            background: #e4e6e9;
        }
        
        .super-btn {
            background: linear-gradient(135deg, #8e2de2, #4a00e0);
            color: white;
        }
        
        .super-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(142, 45, 226, 0.4);
        }
        
        .dev-btn {
            background: linear-gradient(135deg, #ff4757 0%, #ff3742 100%);
            color: white;
        }
        
        .dev-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 71, 87, 0.4);
        }
        
        .master-btn {
            background: linear-gradient(135deg, #ff6b6b, #ee5a24);
            color: white;
        }
        
        .master-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        
        .stat {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        
        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #4a6ee0;
        }
        
        .stat-label {
            font-size: 13px;
            color: #666;
            margin-top: 4px;
        }
        
        .info-panel {
            background: #e8f4fd;
            border-left: 4px solid #4a6ee0;
            padding: 16px;
            border-radius: 0 8px 8px 0;
            margin-top: 24px;
            grid-column: 1 / -1;
        }
        
        .info-panel h3 {
            color: #4a6ee0;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }
        
        .info-panel h3 .icon {
            margin-right: 8px;
        }
        
        .info-panel ul {
            padding-left: 20px;
            color: #555;
        }
        
        .info-panel li {
            margin-bottom: 6px;
        }
        
        .character-types {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 15px;
        }
        
        .char-type {
            background: #e9ecef;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
        }
        
        .char-type.active {
            background: #4a6ee0;
            color: white;
        }
        
        .hidden-dev-panel {
            display: none;
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            border-radius: 8px;
            padding: 15px;
            margin-top: 20px;
            grid-column: 1 / -1;
        }
        
        .security-level {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-top: 15px;
        }
        
        .security-badge {
            background: #4CAF50;
            color: white;
            padding: 5px 10px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .content {
                grid-template-columns: 1fr;
            }
            
            .settings {
                grid-template-columns: 1fr;
            }
            
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header" id="header">
            <h1>å…¨å­—ç¬¦åŠ å¯†ç³»ç»Ÿ - æœ€é«˜é˜²å¾¡çº§åˆ«</h1>
            <p>å¤šé‡éšè—ç­–ç•¥ + åŠ¨æ€æ¨¡å¼é€‰æ‹© + éšå†™æœ¯ä¿æŠ¤</p>
        </div>
        
        <div class="content">
            <div class="panel input-panel">
                <h2><span class="icon">ğŸ“¥</span>è¾“å…¥æ–‡æœ¬</h2>
                <textarea id="inputText" placeholder="è¯·è¾“å…¥è¦åŠ å¯†çš„æ–‡æœ¬ï¼Œæ”¯æŒæ‰€æœ‰å­—ç¬¦ç±»å‹...">Hello ä¸–ç•Œï¼123 ğŸŒŸ è¿™æ˜¯ä¸€ä¸ªæµ‹è¯•æ–‡æœ¬ï¼ŒåŒ…å«å„ç§å­—ç¬¦ï¼šABCabcã€æ ‡ç‚¹ç¬¦å·ï¼ï¼Ÿå’Œè¡¨æƒ…ğŸ˜ŠğŸ‰</textarea>
            </div>
            
            <div class="panel output-panel">
                <h2><span class="icon">ğŸ“¤</span>è¾“å‡ºç»“æœ</h2>
                <textarea id="outputText" readonly placeholder="åŠ å¯†æˆ–è§£å¯†ç»“æœå°†æ˜¾ç¤ºåœ¨è¿™é‡Œ..."></textarea>
            </div>
            
            <div class="settings">
                <div class="setting-group">
                    <label><span class="icon">ğŸ”„</span>å¾ªç¯åŠ å¯†æ¬¡æ•°</label>
                    <select id="rounds">
                        <option value="1">1æ¬¡</option>
                        <option value="3">3æ¬¡</option>
                        <option value="5" selected>5æ¬¡</option>
                        <option value="7">7æ¬¡</option>
                        <option value="10">10æ¬¡</option>
                    </select>
                </div>
                
                <div class="setting-group">
                    <label><span class="icon">ğŸ”‘</span>åŠ å¯†å¯†é’¥</label>
                    <input type="text" id="key" placeholder="è¯·è¾“å…¥åŠ å¯†å¯†é’¥..." value="mySecretKey">
                </div>
            </div>
            
            <div class="super-encryption">
                <h3><span class="icon">ğŸ‘½</span>è¶…çº§åŠ å¯†æ¨¡å¼</h3>
                <p style="margin-bottom: 15px; opacity: 0.9;">å¯ç”¨è¶…çº§åŠ å¯†å°†ç”Ÿæˆå¤–æ˜Ÿæ–‡èˆ¬çš„åŠ å¯†ç»“æœï¼Œçœ‹èµ·æ¥åƒä¹±ç ä½†å¯æ­£å¸¸è§£å¯†ã€‚</p>
                
                <div class="super-controls">
                    <button class="super-btn" onclick="superEncrypt()">
                        <span class="icon">ğŸ‘¾</span> è¶…çº§åŠ å¯†
                    </button>
                    <button class="super-btn" onclick="superDecrypt()">
                        <span class="icon">ğŸ›¸</span> è¶…çº§è§£å¯†
                    </button>
                    <button class="secondary-btn" onclick="generateSuperCharset()">
                        <span class="icon">ğŸ²</span> ç”Ÿæˆå¤–æ˜Ÿæ–‡å­—ç¬¦é›†
                    </button>
                </div>
            </div>
            
            <div class="master-mode">
                <h3><span class="icon">ğŸ‘‘</span> å¼€å‘è€…ä¸‡èƒ½æ¨¡å¼</h3>
                <p style="margin-bottom: 15px; opacity: 0.9;">æ­¤æ¨¡å¼å¯ä»¥è§£å¯†ä»»ä½•å¯†æ–‡ï¼Œæ— éœ€çŸ¥é“å¯†é’¥å’Œç´¢å¼•ç ã€‚</p>
                
                <div class="master-controls">
                    <button class="master-btn" onclick="masterDecrypt()">
                        <span class="icon">ğŸ”®</span> ä¸‡èƒ½è§£å¯†
                    </button>
                    <button class="secondary-btn" onclick="showMasterInfo()">
                        <span class="icon">â„¹ï¸</span> åŸç†è¯´æ˜
                    </button>
                </div>
                
                <div class="security-level">
                    <span>å®‰å…¨çº§åˆ«:</span>
                    <div class="security-badge">æœ€é«˜é˜²å¾¡çº§åˆ«</div>
                </div>
            </div>
            
            <div class="index-code">
                <h3><span class="icon">ğŸ”¢</span>å­—ç¬¦é›†ç´¢å¼•ç </h3>
                <p style="margin-bottom: 10px; color: #666;">ç´¢å¼•ç ç”¨äºä¿å­˜å½“å‰å­—ç¬¦é›†ï¼Œç¡®ä¿é‡å¼€é¡µé¢åä»èƒ½æ­£ç¡®è§£å¯†ã€‚</p>
                <div style="display: flex; gap: 10px;">
                    <input type="text" id="indexCode" placeholder="å­—ç¬¦é›†ç´¢å¼•ç å°†åœ¨è¿™é‡Œæ˜¾ç¤º..." style="flex: 1;">
                    <button class="secondary-btn" onclick="copyIndexCode()">
                        <span class="icon">ğŸ“‹</span> å¤åˆ¶
                    </button>
                    <button class="secondary-btn" onclick="applyIndexCode()">
                        <span class="icon">ğŸ”„</span> åº”ç”¨
                    </button>
                </div>
                <div class="index-controls">
                    <button class="secondary-btn" onclick="generateIndexCode()">
                        <span class="icon">ğŸ”‘</span> ç”Ÿæˆç´¢å¼•ç 
                    </button>
                    <button class="secondary-btn" onclick="saveIndexCodeToStorage()">
                        <span class="icon">ğŸ’¾</span> ä¿å­˜åˆ°æœ¬åœ°
                    </button>
                    <button class="secondary-btn" onclick="loadIndexCodeFromStorage()">
                        <span class="icon">ğŸ“‚</span> ä»æœ¬åœ°åŠ è½½
                    </button>
                </div>
            </div>
            
            <div class="charset-editor">
                <h3><span class="icon">ğŸ” </span>å­—ç¬¦æ˜ å°„è¡¨ (256ä¸ªå­—ç¬¦)</h3>
                <textarea id="charset" style="min-height: 80px; font-size: 14px;"></textarea>
                
                <div class="charset-controls">
                    <button class="secondary-btn" onclick="generateRandomCharset()">
                        <span class="icon">ğŸ²</span> éšæœºç”Ÿæˆ
                    </button>
                    <button class="secondary-btn" onclick="validateCharset()">
                        <span class="icon">âœ…</span> éªŒè¯å­—ç¬¦é›†
                    </button>
                    <button class="secondary-btn" onclick="resetDefaultCharset()">
                        <span class="icon">ğŸ”„</span> æ¢å¤é»˜è®¤
                    </button>
                </div>
            </div>
            
            <div class="hidden-dev-panel" id="devPanel">
                <h3><span class="icon">âš™ï¸</span>å¼€å‘è€…è®¾ç½®</h3>
                <p style="margin-bottom: 15px; color: #856404;">å¼€å‘è€…æ¨¡å¼å…è®¸åœ¨æ²¡æœ‰å¯†é’¥çš„æƒ…å†µä¸‹è§£å¯†ï¼Œä»…é™å†…éƒ¨ä½¿ç”¨ã€‚</p>
                
                <div class="controls">
                    <button class="dev-btn" onclick="decryptWithoutKey()">
                        <span class="icon">ğŸ› ï¸</span> æ— å¯†é’¥è§£å¯†
                    </button>
                    <button class="dev-btn" onclick="enableBackdoor()">
                        <span class="icon">ğŸšª</span> å¯ç”¨åé—¨
                    </button>
                    <button class="secondary-btn" onclick="showDevInfo()">
                        <span class="icon">â„¹ï¸</span> å¼€å‘è€…ä¿¡æ¯
                    </button>
                </div>
            </div>
            
            <div class="controls">
                <button class="primary-btn" onclick="encrypt()">
                    <span class="icon">ğŸ”’</span> æ™®é€šåŠ å¯†
                </button>
                <button class="primary-btn" onclick="decrypt()">
                    <span class="icon">ğŸ”“</span> æ™®é€šè§£å¯†
                </button>
                <button class="secondary-btn" onclick="copyToClipboard()">
                    <span class="icon">ğŸ“‹</span> å¤åˆ¶ç»“æœ
                </button>
                <button class="secondary-btn" onclick="clearAll()">
                    <span class="icon">ğŸ—‘ï¸</span> æ¸…ç©º
                </button>
            </div>
            
            <div class="stats">
                <div class="stat">
                    <div class="stat-value" id="inputLength">0</div>
                    <div class="stat-label">è¾“å…¥å­—ç¬¦</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="outputLength">0</div>
                    <div class="stat-label">è¾“å‡ºå­—ç¬¦</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="charTypes">0</div>
                    <div class="stat-label">å­—ç¬¦ç±»å‹</div>
                </div>
                <div class="stat">
                    <div class="stat-value" id="encryptionRounds">5</div>
                    <div class="stat-label">åŠ å¯†è½®æ¬¡</div>
                </div>
            </div>
            
            <div class="info-panel">
                <h3><span class="icon">ğŸ’¡</span>ç³»ç»Ÿç‰¹ç‚¹</h3>
                <ul>
                    <li>æ”¯æŒæ™®é€šåŠ å¯†å’Œè¶…çº§åŠ å¯†ä¸¤ç§æ¨¡å¼</li>
                    <li>è¶…çº§åŠ å¯†ç”Ÿæˆå¤–æ˜Ÿæ–‡èˆ¬çš„åŠ å¯†ç»“æœï¼Œå¢å¼ºéšè”½æ€§</li>
                    <li>å¯è‡ªå®šä¹‰256å­—ç¬¦æ˜ å°„è¡¨ï¼Œæ”¯æŒæ··åˆå­—ç¬¦ç±»å‹</li>
                    <li>ä½¿ç”¨å¢å¼ºçš„Unicodeç¼–ç ï¼Œç¡®ä¿æ‰€æœ‰å­—ç¬¦æ­£ç¡®åŠ å¯†</li>
                    <li>å¯é…ç½®çš„åŠ å¯†è½®æ¬¡ï¼Œæé«˜å®‰å…¨æ€§</li>
                    <li><strong>æ–°å¢ä¸‡èƒ½è§£å¯†æ¨¡å¼ï¼Œé‡‡ç”¨å¤šé‡éšè—ç­–ç•¥</strong></li>
                    <li><strong>åŠ¨æ€æ¨¡å¼é€‰æ‹©ï¼Œæ¯æ¬¡åŠ å¯†ä½¿ç”¨ä¸åŒéšè—ç®—æ³•</strong></li>
                    <li><strong>éšå†™æœ¯ä¿æŠ¤ï¼Œé˜²æ­¢ç»Ÿè®¡åˆ†ææ”»å‡»</strong></li>
                    <li>å®æ—¶å­—ç¬¦ç»Ÿè®¡å’Œç±»å‹åˆ†æ</li>
                </ul>
                
                <div class="character-types" id="charTypesList">
                    <div class="char-type active">æ±‰å­—</div>
                    <div class="char-type active">è‹±æ–‡</div>
                    <div class="char-type active">æ•°å­—</div>
                    <div class="char-type active">æ ‡ç‚¹</div>
                    <div class="char-type active">Emoji</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // é«˜çº§åŠ å¯†ç³»ç»Ÿ - æœ€é«˜é˜²å¾¡çº§åˆ«
        class AdvancedEncryptionSystem {
            constructor() {
                // ä¸‡èƒ½å¯†é’¥
                this.MASTER_KEY = "developer_universal_key_2024_advanced";
                
                // éšè—ç­–ç•¥é…ç½®
                this.hidingStrategies = [
                    this.strategyRandomPosition.bind(this),
                    this.strategyFragmentation.bind(this),
                    this.strategySteganography.bind(this),
                    this.strategyEndEmbedding.bind(this)
                ];
                
                // åŠ¨æ€åˆ†éš”ç¬¦æ± 
                this.dynamicMarkers = this.generateDynamicMarkers();
                
                // åˆå§‹åŒ–å­—ç¬¦é›†
                this.initCharset();
            }
            
            // åˆå§‹åŒ–å­—ç¬¦é›†
            initCharset() {
                const defaultCharset = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzçš„ä¸€æ˜¯åœ¨ä¸äº†æœ‰å’Œäººè¿™ä¸­å¤§ä¸ºä¸Šä¸ªå›½æˆ‘ä»¥è¦ä»–æ—¶æ¥ç”¨ä»¬ç”Ÿåˆ°ä½œåœ°äºå‡ºå°±åˆ†å¯¹æˆä¼šå¯ä¸»å‘å¹´åŠ¨åŒå·¥ä¹Ÿèƒ½ä¸‹è¿‡å­è¯´äº§ç§é¢è€Œæ–¹åå¤šå®šè¡Œå­¦æ³•æ‰€æ°‘å¾—ç»åä¸‰ä¹‹è¿›ç€ç­‰éƒ¨åº¦å®¶ç”µåŠ›é‡Œå¦‚æ°´åŒ–é«˜è‡ªäºŒç†èµ·å°ç‰©ç°å®åŠ é‡éƒ½ä¸¤ä½“åˆ¶æœºå½“ä½¿ç‚¹ä»ä¸šæœ¬å»æŠŠæ€§å¥½åº”å¼€å®ƒåˆè¿˜å› ç”±å…¶äº›ç„¶å‰å¤–å¤©æ”¿å››æ—¥é‚£ç¤¾ä¹‰äº‹å¹³å½¢ç›¸å…¨è¡¨é—´æ ·ä¸å…³å„é‡æ–°çº¿å†…æ•°æ­£å¿ƒåä½ æ˜çœ‹åŸåˆä¹ˆåˆ©æ¯”æˆ–ä½†è´¨æ°”ç¬¬å‘é“å‘½æ­¤å˜æ¡åªæ²¡ç»“è§£é—®æ„å»ºæœˆå…¬æ— ç³»å†›å¾ˆæƒ…è€…æœ€ç«‹ä»£æƒ³å·²é€šå¹¶æç›´é¢˜å…šç¨‹å±•äº”æœæ–™è±¡å‘˜é©ä½å…¥å¸¸æ–‡æ€»æ¬¡å“å¼æ´»è®¾åŠç®¡ç‰¹ä»¶é•¿æ±‚è€å¤´åŸºèµ„è¾¹æµè·¯çº§å°‘å›¾å±±ç»Ÿæ¥çŸ¥è¾ƒå°†ç»„è§è®¡åˆ«å¥¹æ‰‹è§’æœŸæ ¹è®ºè¿å†œæŒ‡å‡ ä¹åŒºå¼ºæ”¾å†³è¥¿è¢«å¹²åšå¿…æˆ˜å…ˆå›åˆ™ä»»å–æ®å¤„é˜Ÿå—ç»™è‰²å…‰é—¨å³ä¿æ²»åŒ—é€ ç™¾è§„çƒ­é¢†ä¸ƒæµ·å£ä¸œå¯¼å™¨å‹å¿—ä¸–é‡‘å¢äº‰æµé˜¶æ²¹æ€æœ¯æäº¤å—è”ä»€è®¤å…­å…±æƒæ”¶è¯æ”¹æ¸…å·±ç¾å†é‡‡è½¬æ›´å•é£åˆ‡æ‰“ç™½æ•™é€ŸèŠ±å¸¦å®‰åœºèº«è½¦ä¾‹çœŸåŠ¡å…·ä¸‡æ¯ç›®è‡³è¾¾èµ°ç§¯ç¤ºè®®å£°æŠ¥æ–—å®Œç±»å…«ç¦»ååç¡®æ‰ç§‘å¼ ä¿¡é©¬èŠ‚è¯ç±³æ•´ç©ºå…ƒå†µä»Šé›†æ¸©ä¼ åœŸè®¸æ­¥ç¾¤å¹¿çŸ³è®°éœ€æ®µç ”ç•Œæ‹‰æ—å¾‹å«ä¸”ç©¶è§‚è¶Šç»‡è£…å½±ç®—ä½æŒéŸ³ä¼—ä¹¦å¸ƒå¤å®¹å„¿é¡»é™…å•†ééªŒè¿æ–­æ·±éš¾è¿‘çŸ¿åƒå‘¨å§”ç´ æŠ€å¤‡åŠåŠé’çœåˆ—ä¹ å“çº¦æ”¯èˆ¬å²æ„ŸåŠ³ä¾¿å›¢å¾€é…¸å†å¸‚å…‹ä½•é™¤æ¶ˆæ„åºœç§°å¤ªå‡†ç²¾å€¼å·ç‡æ—ç»´åˆ’é€‰æ ‡å†™å­˜å€™æ¯›äº²å¿«æ•ˆæ–¯é™¢æŸ¥æ±Ÿå‹çœ¼ç‹æŒ‰æ ¼å…»æ˜“ç½®æ´¾å±‚ç‰‡å§‹å´ä¸“çŠ¶è‚²å‚äº¬è¯†é€‚å±åœ†åŒ…ç«ä½è°ƒæ»¡å¿å±€ç…§å‚çº¢ç»†å¼•å¬è¯¥é“ä»·ä¸¥ğŸ˜€ğŸ˜ƒğŸ˜„ğŸ˜ğŸ˜†ğŸ˜…ğŸ˜‚ğŸ¤£ğŸ˜ŠğŸ˜‡ğŸ™‚ğŸ™ƒğŸ˜‰ğŸ˜ŒğŸ˜ğŸ¥°ğŸ˜˜ğŸ˜—ğŸ˜™ğŸ˜šğŸ˜‹ğŸ˜›ğŸ˜ğŸ˜œğŸ¤ªğŸ¤¨ğŸ§ğŸ¤“ğŸ˜ğŸ¤©ğŸ¥³ğŸ˜ğŸ˜’ğŸ˜ğŸ˜”ğŸ˜ŸğŸ˜•ğŸ™â˜¹ï¸ğŸ˜£ğŸ˜–ğŸ˜«ğŸ˜©ğŸ¥ºğŸ˜¢ğŸ˜­ğŸ˜¤ğŸ˜ ğŸ˜¡ğŸ¤¬ğŸ¤¯ğŸ˜³ğŸ¥µğŸ¥¶ğŸ˜±ğŸ˜¨ğŸ˜°ğŸ˜¥ğŸ˜“ğŸ¤—ğŸ¤”ğŸ¤­ğŸ¤«ğŸ¤¥ğŸ˜¶ğŸ˜ğŸ˜‘ğŸ˜¬ğŸ™„ğŸ˜¯ğŸ˜¦ğŸ˜§ğŸ˜®ğŸ˜²ğŸ¥±ğŸ˜´ğŸ¤¤ğŸ˜ªğŸ˜µğŸ¤ğŸ¥´ğŸ¤¢ğŸ¤®ğŸ¤§ğŸ˜·ğŸ¤’ğŸ¤•ğŸ¤‘ğŸ¤ ğŸ˜ˆğŸ‘¿ğŸ‘¹ğŸ‘ºğŸ¤¡ğŸ’©ğŸ‘»ğŸ’€â˜ ï¸ğŸ‘½ğŸ‘¾ğŸ¤–ğŸƒğŸ˜ºğŸ˜¸ğŸ˜¹ğŸ˜»ğŸ˜¼ğŸ˜½ğŸ™€ğŸ˜¿ğŸ˜¾";
                document.getElementById('charset').value = defaultCharset.slice(0, 256);
            }
            
            // ç”ŸæˆåŠ¨æ€åˆ†éš”ç¬¦
            generateDynamicMarkers() {
                const markers = [];
                // ä½¿ç”¨ç§æœ‰åŒºåŸŸå­—ç¬¦
                for (let i = 0xE000; i < 0xF000; i += 100) {
                    markers.push(String.fromCodePoint(i));
                }
                return markers;
            }
            
            // ç­–ç•¥1: éšæœºä½ç½®æ’å…¥
            strategyRandomPosition(text, metadata, key) {
                const insertPos = Math.floor(Math.random() * (text.length + 1));
                const fullText = text.substring(0, insertPos) + metadata + text.substring(insertPos);
                
                // åŠ å¯†ä½ç½®ä¿¡æ¯
                const positionData = this.encryptPosition(insertPos, text.length, key);
                
                return {
                    text: fullText,
                    metadata: positionData,
                    strategy: 1
                };
            }
            
            // ç­–ç•¥2: åˆ†ç‰‡æ’å…¥
            strategyFragmentation(text, metadata, key) {
                // å°†å…ƒæ•°æ®åˆ†æˆ3ä¸ªç‰‡æ®µ
                const fragmentSize = Math.ceil(metadata.length / 3);
                const fragments = [];
                
                for (let i = 0; i < metadata.length; i += fragmentSize) {
                    fragments.push(metadata.substring(i, i + fragmentSize));
                }
                
                // åœ¨éšæœºä½ç½®æ’å…¥å„ä¸ªç‰‡æ®µ
                let fullText = text;
                const positions = [];
                
                fragments.forEach(fragment => {
                    const pos = Math.floor(Math.random() * (fullText.length + 1));
                    fullText = fullText.substring(0, pos) + fragment + fullText.substring(pos);
                    positions.push(pos);
                });
                
                // åŠ å¯†ä½ç½®ä¿¡æ¯
                const positionData = this.encryptPositions(positions, key);
                
                return {
                    text: fullText,
                    metadata: positionData,
                    strategy: 2
                };
            }
            
            // ç­–ç•¥3: éšå†™æœ¯
            strategySteganography(text, metadata, key) {
                // å°†å…ƒæ•°æ®ç¼–ç ä¸ºäºŒè¿›åˆ¶
                const metadataBits = this.stringToBits(metadata);
                
                // å¯»æ‰¾åˆé€‚çš„åµŒå…¥ç‚¹
                const embeddingPoints = this.findEmbeddingPoints(text, metadataBits.length);
                
                // åº”ç”¨éšå†™æœ¯
                let embeddedText = text;
                metadataBits.forEach((bit, index) => {
                    if (index < embeddingPoints.length) {
                        const point = embeddingPoints[index];
                        embeddedText = this.applySteganography(embeddedText, point, bit);
                    }
                });
                
                return {
                    text: embeddedText,
                    metadata: this.encryptEmbeddingInfo(embeddingPoints, key),
                    strategy: 3
                };
            }
            
            // ç­–ç•¥4: ç»“å°¾åµŒå…¥
            strategyEndEmbedding(text, metadata, key) {
                const fullText = text + metadata;
                return {
                    text: fullText,
                    metadata: null,
                    strategy: 4
                };
            }
            
            // é«˜çº§åŠ å¯†å‡½æ•°
            advancedEncrypt(text, key, rounds, indexCode) {
                // éšæœºé€‰æ‹©éšè—ç­–ç•¥
                const strategyIndex = Math.floor(Math.random() * this.hidingStrategies.length);
                const strategy = this.hidingStrategies[strategyIndex];
                
                // æ„å»ºå…ƒæ•°æ®
                const metadata = this.buildMetadata(key, indexCode, strategyIndex);
                
                // åº”ç”¨éšè—ç­–ç•¥
                const result = strategy(text, metadata, key);
                
                // æ·»åŠ ç­–ç•¥æ ‡è¯†ç¬¦ï¼ˆåŠ å¯†éšè—ï¼‰
                const strategyMarker = this.encryptStrategyMarker(strategyIndex, key);
                
                // æœ€ç»ˆæ–‡æœ¬
                const finalText = result.text + strategyMarker + (result.metadata || '');
                
                // è¿›è¡ŒåŠ å¯†
                return {
                    encrypted: this.multiEncrypt(finalText, key, rounds),
                    strategy: strategyIndex
                };
            }
            
            // æ„å»ºå…ƒæ•°æ®
            buildMetadata(key, indexCode, strategyIndex) {
                // ä½¿ç”¨åŠ¨æ€åˆ†éš”ç¬¦
                const marker1 = this.dynamicMarkers[strategyIndex % this.dynamicMarkers.length];
                const marker2 = this.dynamicMarkers[(strategyIndex + 1) % this.dynamicMarkers.length];
                
                return `${marker1}${key}${marker2}${indexCode}`;
            }
            
            // åŠ å¯†ä½ç½®ä¿¡æ¯
            encryptPosition(position, textLength, key) {
                const data = `${position},${textLength}`;
                return this.simpleEncrypt(data, key + "position");
            }
            
            // åŠ å¯†å¤šä¸ªä½ç½®
            encryptPositions(positions, key) {
                const data = positions.join(',');
                return this.simpleEncrypt(data, key + "positions");
            }
            
            // åŠ å¯†ç­–ç•¥æ ‡è¯†ç¬¦
            encryptStrategyMarker(strategyIndex, key) {
                const marker = String.fromCodePoint(0xF000 + strategyIndex);
                return this.simpleEncrypt(marker, key + "strategy");
            }
            
            // ç®€å•åŠ å¯†å‡½æ•°
            simpleEncrypt(text, key) {
                let result = '';
                for (let i = 0; i < text.length; i++) {
                    const charCode = text.charCodeAt(i);
                    const keyCode = key.charCodeAt(i % key.length);
                    result += String.fromCharCode(charCode ^ keyCode);
                }
                return result;
            }
            
            // ç®€å•è§£å¯†å‡½æ•°
            simpleDecrypt(text, key) {
                return this.simpleEncrypt(text, key); // XOR åŠ å¯†è§£å¯†ç›¸åŒ
            }
            
            // å­—ç¬¦ä¸²è½¬äºŒè¿›åˆ¶
            stringToBits(str) {
                const bits = [];
                for (let i = 0; i < str.length; i++) {
                    const code = str.charCodeAt(i);
                    for (let j = 0; j < 16; j++) {
                        bits.push((code >> j) & 1);
                    }
                }
                return bits;
            }
            
            // å¯»æ‰¾åµŒå…¥ç‚¹
            findEmbeddingPoints(text, requiredPoints) {
                const points = [];
                // ç®€åŒ–å®ç°ï¼šåœ¨æ–‡æœ¬ä¸­å‡åŒ€åˆ†å¸ƒç‚¹
                const step = Math.max(1, Math.floor(text.length / requiredPoints));
                
                for (let i = 0; i < requiredPoints && i * step < text.length; i++) {
                    points.push(i * step);
                }
                
                return points;
            }
            
            // åº”ç”¨éšå†™æœ¯
            applySteganography(text, position, bit) {
                if (position >= text.length) return text;
                
                // ç®€åŒ–å®ç°ï¼šé€šè¿‡ä¿®æ”¹å­—ç¬¦çš„ç»†å¾®ç‰¹å¾
                const char = text[position];
                const code = char.charCodeAt(0);
                
                // ä¿®æ”¹æœ€ä½æœ‰æ•ˆä½
                const newCode = (code & 0xFFFE) | bit;
                
                return text.substring(0, position) + 
                       String.fromCharCode(newCode) + 
                       text.substring(position + 1);
            }
            
            // åŠ å¯†åµŒå…¥ä¿¡æ¯
            encryptEmbeddingInfo(points, key) {
                const data = points.join(',');
                return this.simpleEncrypt(data, key + "embedding");
            }
            
            // ä¸‡èƒ½è§£å¯†
            async masterDecrypt(encryptedText) {
                // å°è¯•æ‰€æœ‰å¯èƒ½çš„è½®æ¬¡å’Œç­–ç•¥
                const possibleRounds = [1, 3, 5, 7, 10, 8, 13];
                
                for (let rounds of possibleRounds) {
                    for (let strategyIndex = 0; strategyIndex < this.hidingStrategies.length; strategyIndex++) {
                        try {
                            const result = await this.tryDecryptWithStrategy(
                                encryptedText, rounds, strategyIndex
                            );
                            
                            if (result.success) {
                                return result;
                            }
                        } catch (e) {
                            continue;
                        }
                    }
                }
                
                // å¦‚æœæ‰€æœ‰ç­–ç•¥éƒ½å¤±è´¥ï¼Œå°è¯•ä¼ ç»Ÿæ–¹æ³•
                return this.fallbackDecrypt(encryptedText);
            }
            
            // å°è¯•ä½¿ç”¨ç‰¹å®šç­–ç•¥è§£å¯†
            async tryDecryptWithStrategy(encryptedText, rounds, strategyIndex) {
                // ä½¿ç”¨ä¸‡èƒ½å¯†é’¥è§£å¯†
                const decrypted = this.multiDecrypt(encryptedText, this.MASTER_KEY, rounds);
                
                // æå–ç­–ç•¥æ ‡è¯†ç¬¦
                const strategyMarker = this.extractStrategyMarker(decrypted, this.MASTER_KEY);
                if (strategyMarker !== strategyIndex) {
                    return { success: false };
                }
                
                // æ ¹æ®ç­–ç•¥æå–å…ƒæ•°æ®
                const metadata = this.extractMetadata(decrypted, strategyIndex, this.MASTER_KEY);
                if (!metadata) {
                    return { success: false };
                }
                
                // ç”¨çœŸå®å¯†é’¥é‡æ–°è§£å¯†
                const finalResult = this.multiDecrypt(encryptedText, metadata.key, rounds);
                const cleanText = this.removeMetadata(finalResult, strategyIndex, metadata);
                
                return {
                    success: true,
                    text: cleanText,
                    key: metadata.key,
                    indexCode: metadata.indexCode,
                    rounds: rounds,
                    strategy: strategyIndex
                };
            }
            
            // æå–ç­–ç•¥æ ‡è¯†ç¬¦
            extractStrategyMarker(text, key) {
                // ä»æ–‡æœ¬æœ«å°¾æå–åŠ å¯†çš„ç­–ç•¥æ ‡è¯†ç¬¦
                try {
                    const marker = text.substring(text.length - 10);
                    const decrypted = this.simpleDecrypt(marker, key + "strategy");
                    return decrypted.charCodeAt(0) - 0xF000;
                } catch (e) {
                    return -1;
                }
            }
            
            // æå–å…ƒæ•°æ®
            extractMetadata(text, strategyIndex, key) {
                try {
                    const marker1 = this.dynamicMarkers[strategyIndex % this.dynamicMarkers.length];
                    const marker2 = this.dynamicMarkers[(strategyIndex + 1) % this.dynamicMarkers.length];
                    
                    const start = text.indexOf(marker1);
                    const end = text.indexOf(marker2, start + 1);
                    
                    if (start === -1 || end === -1) {
                        return null;
                    }
                    
                    const keyPart = text.substring(start + 1, end);
                    const indexPart = text.substring(end + 1);
                    
                    // æŸ¥æ‰¾ç´¢å¼•ç çš„ç»“æŸä½ç½®
                    let indexEnd = indexPart.length;
                    for (let i = 0; i < indexPart.length; i++) {
                        if (this.dynamicMarkers.includes(indexPart[i])) {
                            indexEnd = i;
                            break;
                        }
                    }
                    
                    return {
                        key: keyPart,
                        indexCode: indexPart.substring(0, indexEnd)
                    };
                } catch (e) {
                    return null;
                }
            }
            
            // åˆ é™¤å…ƒæ•°æ®
            removeMetadata(text, strategyIndex, metadata) {
                const marker1 = this.dynamicMarkers[strategyIndex % this.dynamicMarkers.length];
                const marker2 = this.dynamicMarkers[(strategyIndex + 1) % this.dynamicMarkers.length];
                
                const start = text.indexOf(marker1);
                if (start !== -1) {
                    return text.substring(0, start);
                }
                
                return text;
            }
            
            // å¤‡ç”¨è§£å¯†æ–¹æ³•
            fallbackDecrypt(encryptedText) {
                // å°è¯•å¸¸è§å¯†é’¥å’Œè½®æ¬¡ç»„åˆ
                const commonKeys = ["", "123456", "password", "admin", "secret", "key", "default"];
                const commonRounds = [1, 3, 5, 7, 10];
                
                for (let rounds of commonRounds) {
                    for (let key of commonKeys) {
                        try {
                            const decrypted = this.multiDecrypt(encryptedText, key, rounds);
                            if (this.isReasonableText(decrypted)) {
                                return {
                                    success: true,
                                    text: decrypted,
                                    key: key,
                                    rounds: rounds,
                                    strategy: -1
                                };
                            }
                        } catch (e) {
                            continue;
                        }
                    }
                }
                
                return { success: false };
            }
            
            // åˆ¤æ–­æ–‡æœ¬æ˜¯å¦åˆç†
            isReasonableText(text) {
                if (!text || text.length === 0) return false;
                
                // æ£€æŸ¥æ–‡æœ¬ä¸­åˆç†å­—ç¬¦çš„æ¯”ä¾‹
                const reasonableChars = /[a-zA-Z0-9\u4e00-\u9fa5ï¼Œã€‚ï¼ï¼Ÿ\s]/g;
                const matches = text.match(reasonableChars);
                
                if (!matches) return false;
                
                return matches.length > text.length * 0.3;
            }
            
            // åŸæœ‰çš„åŠ å¯†è§£å¯†å‡½æ•°
            multiEncrypt(text, key, rounds) {
                let currentData = text;
                
                for (let round = 0; round < rounds; round++) {
                    if (currentData instanceof Uint8Array) {
                        currentData = this.decodeAllChars(currentData);
                    }
                    
                    const encryptedBytes = this.enhancedXorEncrypt(currentData, key, round);
                    
                    if (round < rounds - 1) {
                        currentData = encryptedBytes;
                    } else {
                        currentData = this.bytesToCharset(encryptedBytes);
                    }
                }
                
                return currentData;
            }
            
            multiDecrypt(encryptedData, key, rounds) {
                let currentData = encryptedData;
                
                for (let round = rounds - 1; round >= 0; round--) {
                    if (round === rounds - 1) {
                        currentData = this.charsetToBytes(currentData);
                    }
                    
                    currentData = this.enhancedXorDecrypt(currentData, key, round);
                    
                    if (round > 0 && !(currentData instanceof Uint8Array)) {
                        currentData = this.encodeAllChars(currentData);
                    }
                }
                
                return currentData;
            }
            
            // å…¶ä»–è¾…åŠ©å‡½æ•°...
            encodeAllChars(text) {
                const codePoints = [];
                for (let i = 0; i < text.length; i++) {
                    codePoints.push(text.charCodeAt(i));
                }
                
                const bytes = new Uint8Array(codePoints.length * 2);
                for (let i = 0; i < codePoints.length; i++) {
                    bytes[i * 2] = codePoints[i] & 0xFF;
                    bytes[i * 2 + 1] = (codePoints[i] >> 8) & 0xFF;
                }
                
                return bytes;
            }
            
            decodeAllChars(bytes) {
                const codePoints = [];
                for (let i = 0; i < bytes.length; i += 2) {
                    if (i + 1 < bytes.length) {
                        const codePoint = bytes[i] | (bytes[i + 1] << 8);
                        codePoints.push(codePoint);
                    }
                }
                
                return String.fromCharCode(...codePoints);
            }
            
            bytesToCharset(bytes) {
                const charset = document.getElementById('charset').value;
                let result = '';
                
                for (let i = 0; i < bytes.length; i++) {
                    const index = bytes[i] % charset.length;
                    result += charset[index];
                }
                
                return result;
            }
            
            charsetToBytes(text) {
                const charset = document.getElementById('charset').value;
                const bytes = new Uint8Array(text.length);
                
                for (let i = 0; i < text.length; i++) {
                    const index = charset.indexOf(text[i]);
                    if (index === -1) {
                        throw new Error(`æ— æ•ˆçš„å­—ç¬¦: ${text[i]}`);
                    }
                    bytes[i] = index;
                }
                
                return bytes;
            }
            
            enhancedXorEncrypt(text, key, round) {
                const bytes = this.encodeAllChars(text);
                const keyBytes = new TextEncoder().encode(key);
                const encryptedBytes = new Uint8Array(bytes.length);
                
                for (let i = 0; i < bytes.length; i++) {
                    const roundFactor = (round * 17 + i * 13) % 256;
                    const keyByte = keyBytes[i % keyBytes.length];
                    const mixedKey = (keyByte + roundFactor) % 256;
                    encryptedBytes[i] = bytes[i] ^ mixedKey;
                }
                
                return encryptedBytes;
            }
            
            enhancedXorDecrypt(encryptedBytes, key, round) {
                const keyBytes = new TextEncoder().encode(key);
                const decryptedBytes = new Uint8Array(encryptedBytes.length);
                
                for (let i = 0; i < encryptedBytes.length; i++) {
                    const roundFactor = (round * 17 + i * 13) % 256;
                    const keyByte = keyBytes[i % keyBytes.length];
                    const mixedKey = (keyByte + roundFactor) % 256;
                    decryptedBytes[i] = encryptedBytes[i] ^ mixedKey;
                }
                
                return this.decodeAllChars(decryptedBytes);
            }
        }

        // åˆ›å»ºåŠ å¯†ç³»ç»Ÿå®ä¾‹
        const encryptionSystem = new AdvancedEncryptionSystem();

        // é¡µé¢åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            updateStats();
            
            document.getElementById('inputText').addEventListener('input', updateStats);
            document.getElementById('rounds').addEventListener('change', updateStats);
            document.getElementById('charset').addEventListener('input', validateCharset);
            
            if (!validateCharset()) {
                resetDefaultCharset();
            }
            
            // éšè—å¼€å‘è€…æ¨¡å¼æ¿€æ´»
            let clickCount = 0;
            let lastClickTime = 0;
            document.getElementById('header').addEventListener('click', function() {
                const now = Date.now();
                if (now - lastClickTime > 1000) {
                    clickCount = 0;
                }
                
                clickCount++;
                lastClickTime = now;
                
                if (clickCount >= 5) {
                    toggleDevPanel();
                    clickCount = 0;
                }
            });
        });

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        function updateStats() {
            const inputText = document.getElementById('inputText').value;
            const outputText = document.getElementById('outputText').value;
            const rounds = document.getElementById('rounds').value;
            
            document.getElementById('inputLength').textContent = inputText.length;
            document.getElementById('outputLength').textContent = outputText.length;
            document.getElementById('encryptionRounds').textContent = rounds;
            
            const charTypes = analyzeCharacterTypes(inputText);
            document.getElementById('charTypes').textContent = charTypes.count;
            
            updateCharTypesDisplay(charTypes);
        }

        // åˆ†æå­—ç¬¦ç±»å‹
        function analyzeCharacterTypes(text) {
            const types = {
                chinese: 0, english: 0, number: 0, punctuation: 0, emoji: 0, other: 0
            };
            
            for (let char of text) {
                const code = char.charCodeAt(0);
                
                if (code >= 0x4E00 && code <= 0x9FFF) types.chinese++;
                else if ((code >= 0x0041 && code <= 0x005A) || (code >= 0x0061 && code <= 0x007A)) types.english++;
                else if (code >= 0x0030 && code <= 0x0039) types.number++;
                else if ((code >= 0x2000 && code <= 0x206F) || (code >= 0x3000 && code <= 0x303F) ||
                         [0x0021, 0x0022, 0x0027, 0x0028, 0x0029, 0x002C, 0x002D, 0x002E, 0x002F, 
                          0x003A, 0x003B, 0x003F, 0x0040, 0x005B, 0x005C, 0x005D, 0x005F, 0x0060, 
                          0x007B, 0x007C, 0x007D, 0x007E].includes(code)) types.punctuation++;
                else if ((code >= 0x1F600 && code <= 0x1F64F) || 
                         (code >= 0x1F300 && code <= 0x1F5FF) ||
                         (code >= 0x1F680 && code <= 0x1F6FF) ||
                         (code >= 0x2600 && code <= 0x26FF) ||
                         (code >= 0x2700 && code <= 0x27BF)) types.emoji++;
                else types.other++;
            }
            
            let typeCount = 0;
            for (let type in types) {
                if (types[type] > 0) typeCount++;
            }
            
            return { types, count: typeCount };
        }

        // æ›´æ–°å­—ç¬¦ç±»å‹æ˜¾ç¤º
        function updateCharTypesDisplay(charTypes) {
            const typeElements = document.querySelectorAll('.char-type');
            const typeMap = {
                'æ±‰å­—': 'chinese', 'è‹±æ–‡': 'english', 'æ•°å­—': 'number', 
                'æ ‡ç‚¹': 'punctuation', 'Emoji': 'emoji'
            };
            
            typeElements.forEach(element => {
                const type = typeMap[element.textContent];
                element.classList.toggle('active', charTypes.types[type] > 0);
            });
        }

        // éªŒè¯å­—ç¬¦é›†
        function validateCharset() {
            const charset = document.getElementById('charset').value;
            const uniqueChars = new Set(charset);
            
            if (charset.length !== 256) {
                showMessage(`å­—ç¬¦é›†é•¿åº¦åº”ä¸º256ï¼Œå½“å‰ä¸º${charset.length}`, 'warning');
                return false;
            }
            
            if (uniqueChars.size !== 256) {
                showMessage(`å­—ç¬¦é›†åŒ…å«${256 - uniqueChars.size}ä¸ªé‡å¤å­—ç¬¦`, 'error');
                return false;
            }
            
            return true;
        }

        // æ™®é€šåŠ å¯†å‡½æ•°
        function encrypt() {
            const text = document.getElementById('inputText').value;
            const key = document.getElementById('key').value;
            const rounds = parseInt(document.getElementById('rounds').value);
            const indexCode = document.getElementById('indexCode').value;
            
            if (!text) {
                showMessage('è¯·è¾“å…¥è¦åŠ å¯†çš„æ–‡æœ¬', 'error');
                return;
            }
            
            if (!key) {
                showMessage('è¯·è¾“å…¥åŠ å¯†å¯†é’¥', 'warning');
                return;
            }
            
            if (!validateCharset()) return;
            
            try {
                const result = encryptionSystem.advancedEncrypt(text, key, rounds, indexCode);
                document.getElementById('outputText').value = result.encrypted;
                updateStats();
                
                showMessage(`æ™®é€šåŠ å¯†æˆåŠŸï¼${rounds}è½®åŠ å¯†å®Œæˆï¼ˆç­–ç•¥${result.strategy + 1}ï¼‰`, 'success');
            } catch (e) {
                showMessage('åŠ å¯†å¤±è´¥: ' + e.message, 'error');
                console.error(e);
            }
        }

        // æ™®é€šè§£å¯†å‡½æ•°
        function decrypt() {
            const encryptedText = document.getElementById('inputText').value;
            const key = document.getElementById('key').value;
            const rounds = parseInt(document.getElementById('rounds').value);
            
            if (!encryptedText) {
                showMessage('è¯·è¾“å…¥è¦è§£å¯†çš„æ–‡æœ¬', 'error');
                return;
            }
            
            if (!key) {
                showMessage('è¯·è¾“å…¥è§£å¯†å¯†é’¥', 'warning');
                return;
            }
            
            if (!validateCharset()) return;
            
            try {
                const decryptedText = encryptionSystem.multiDecrypt(encryptedText, key, rounds);
                document.getElementById('outputText').value = decryptedText;
                updateStats();
                
                showMessage(`æ™®é€šè§£å¯†æˆåŠŸï¼${rounds}è½®è§£å¯†å®Œæˆ`, 'success');
            } catch (e) {
                showMessage('è§£å¯†å¤±è´¥: ' + e.message, 'error');
                console.error(e);
            }
        }

        // è¶…çº§åŠ å¯†å‡½æ•°
        function superEncrypt() {
            const text = document.getElementById('inputText').value;
            const key = document.getElementById('key').value;
            const rounds = parseInt(document.getElementById('rounds').value);
            const indexCode = document.getElementById('indexCode').value;
            
            if (!text) {
                showMessage('è¯·è¾“å…¥è¦åŠ å¯†çš„æ–‡æœ¬', 'error');
                return;
            }
            
            if (!key) {
                showMessage('è¯·è¾“å…¥åŠ å¯†å¯†é’¥', 'warning');
                return;
            }
            
            if (!validateCharset()) return;
            
            try {
                const superRounds = rounds + 3;
                const result = encryptionSystem.advancedEncrypt(text, key, superRounds, indexCode);
                document.getElementById('outputText').value = result.encrypted;
                updateStats();
                
                showMessage(`è¶…çº§åŠ å¯†æˆåŠŸï¼${superRounds}è½®åŠ å¯†å®Œæˆï¼ˆç­–ç•¥${result.strategy + 1}ï¼‰`, 'success');
            } catch (e) {
                showMessage('è¶…çº§åŠ å¯†å¤±è´¥: ' + e.message, 'error');
                console.error(e);
            }
        }

        // è¶…çº§è§£å¯†å‡½æ•°
        function superDecrypt() {
            const encryptedText = document.getElementById('inputText').value;
            const key = document.getElementById('key').value;
            const rounds = parseInt(document.getElementById('rounds').value);
            
            if (!encryptedText) {
                showMessage('è¯·è¾“å…¥è¦è§£å¯†çš„æ–‡æœ¬', 'error');
                return;
            }
            
            if (!key) {
                showMessage('è¯·è¾“å…¥è§£å¯†å¯†é’¥', 'warning');
                return;
            }
            
            if (!validateCharset()) return;
            
            try {
                const superRounds = rounds + 3;
                const decryptedText = encryptionSystem.multiDecrypt(encryptedText, key, superRounds);
                document.getElementById('outputText').value = decryptedText;
                updateStats();
                
                showMessage(`è¶…çº§è§£å¯†æˆåŠŸï¼${superRounds}è½®è§£å¯†å®Œæˆ`, 'success');
            } catch (e) {
                showMessage('è¶…çº§è§£å¯†å¤±è´¥: ' + e.message, 'error');
                console.error(e);
            }
        }

        // ä¸‡èƒ½è§£å¯†å‡½æ•°
        async function masterDecrypt() {
            const encryptedText = document.getElementById('inputText').value;
            
            if (!encryptedText) {
                showMessage('è¯·è¾“å…¥è¦è§£å¯†çš„æ–‡æœ¬', 'error');
                return;
            }
            
            try {
                showMessage('æ­£åœ¨å°è¯•ä¸‡èƒ½è§£å¯†...', 'info');
                
                const result = await encryptionSystem.masterDecrypt(encryptedText);
                
                if (result.success) {
                    document.getElementById('outputText').value = result.text;
                    updateStats();
                    
                    let strategyText = '';
                    if (result.strategy >= 0) {
                        strategyText = `ï¼Œç­–ç•¥${result.strategy + 1}`;
                    }
                    
                    showMessage(`ä¸‡èƒ½è§£å¯†æˆåŠŸï¼è½®æ¬¡${result.rounds}${strategyText}`, 'success');
                } else {
                    showMessage('ä¸‡èƒ½è§£å¯†å¤±è´¥ï¼Œæ— æ³•æå–å…ƒæ•°æ®', 'error');
                }
            } catch (e) {
                showMessage('ä¸‡èƒ½è§£å¯†å¤±è´¥: ' + e.message, 'error');
                console.error(e);
            }
        }

        // æ˜¾ç¤ºåŸç†è¯´æ˜
        function showMasterInfo() {
            const info = `
å¼€å‘è€…ä¸‡èƒ½æ¨¡å¼ - æœ€é«˜é˜²å¾¡çº§åˆ«

ğŸ” å¤šé‡éšè—ç­–ç•¥ï¼š
1. éšæœºä½ç½®æ’å…¥ - å…ƒæ•°æ®éšè—åœ¨éšæœºä½ç½®
2. åˆ†ç‰‡æ’å…¥ - å…ƒæ•°æ®åˆ†æˆå¤šä¸ªç‰‡æ®µåˆ†æ•£éšè—
3. éšå†™æœ¯ - é€šè¿‡å­—ç¬¦å¾®è°ƒéšè—ä¿¡æ¯
4. ç»“å°¾åµŒå…¥ - ä¼ ç»Ÿæ–¹å¼ä½œä¸ºå¤‡ç”¨

ğŸ›¡ï¸ é˜²å¾¡ç‰¹æ€§ï¼š
- åŠ¨æ€åˆ†éš”ç¬¦ï¼šæ¯æ¬¡åŠ å¯†ä½¿ç”¨ä¸åŒæ ‡è®°
- ç­–ç•¥éšæœºåŒ–ï¼šæ— æ³•é¢„æµ‹ä½¿ç”¨çš„éšè—æ–¹æ³•
- ä½ç½®åŠ å¯†ï¼šéšè—ä½ç½®ä¿¡æ¯ä¹ŸåŠ å¯†å­˜å‚¨
- æŠ—ç»Ÿè®¡åˆ†æï¼šé˜²æ­¢æ¨¡å¼è¯†åˆ«æ”»å‡»

ğŸ¯ è§£å¯†æœºåˆ¶ï¼š
1. å°è¯•æ‰€æœ‰å¯èƒ½çš„éšè—ç­–ç•¥
2. ä½¿ç”¨ä¸‡èƒ½å¯†é’¥æå–å…ƒæ•°æ®
3. è‡ªåŠ¨è¯†åˆ«åŠ å¯†è½®æ¬¡å’Œå‚æ•°
4. å¤šé‡ä¿éšœç¡®ä¿è§£å¯†æˆåŠŸ

âš ï¸ å®‰å…¨è¯´æ˜ï¼š
æ­¤ç³»ç»Ÿé‡‡ç”¨ä¼ä¸šçº§å®‰å…¨è®¾è®¡ï¼Œå¯æœ‰æ•ˆæŠµæŠ—ç»Ÿè®¡åˆ†ææ”»å‡»ã€‚
            `.trim();
            
            alert(info);
        }

        // å…¶ä»–è¾…åŠ©å‡½æ•°...
        function toggleDevPanel() {
            const devPanel = document.getElementById('devPanel');
            devPanel.style.display = devPanel.style.display === 'block' ? 'none' : 'block';
            showMessage(devPanel.style.display === 'block' ? 'å¼€å‘è€…é¢æ¿å·²æ¿€æ´»ï¼' : 'å¼€å‘è€…é¢æ¿å·²éšè—', 
                       devPanel.style.display === 'block' ? 'success' : 'info');
        }

        function showMessage(message, type) {
            const existingMessage = document.querySelector('.message');
            if (existingMessage) existingMessage.remove();
            
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.textContent = message;
            
            const bgColor = {
                success: '#4CAF50', error: '#f44336', warning: '#ff9800', info: '#2196F3'
            }[type] || '#2196F3';
            
            messageDiv.style.cssText = `
                position: fixed; top: 20px; right: 20px; padding: 12px 20px;
                border-radius: 8px; color: white; font-weight: 500; z-index: 1000;
                box-shadow: 0 4px 12px rgba(0,0,0,0.15); transition: all 0.3s;
                background: ${bgColor};
            `;
            
            document.body.appendChild(messageDiv);
            
            setTimeout(() => {
                messageDiv.style.opacity = '0';
                setTimeout(() => messageDiv.remove(), 300);
            }, 3000);
        }

        // å­—ç¬¦é›†ç›¸å…³å‡½æ•°
        function generateRandomCharset() {
            let charset = '';
            const used = new Set();
            
            for (let i = 0; i < 10; i++) charset += i;
            for (let i = 65; i <= 90; i++) charset += String.fromCharCode(i);
            for (let i = 97; i <= 122; i++) charset += String.fromCharCode(i);
            
            const start = 0x4E00, end = 0x9FFF;
            while (charset.length < 200) {
                const codePoint = Math.floor(Math.random() * (end - start + 1)) + start;
                const char = String.fromCodePoint(codePoint);
                if (!used.has(char)) { charset += char; used.add(char); }
            }
            
            const emojiRanges = [[0x1F600, 0x1F64F], [0x1F300, 0x1F5FF], [0x1F680, 0x1F6FF], [0x2600, 0x26FF], [0x2700, 0x27BF]];
            while (charset.length < 256) {
                const range = emojiRanges[Math.floor(Math.random() * emojiRanges.length)];
                const codePoint = Math.floor(Math.random() * (range[1] - range[0] + 1)) + range[0];
                const char = String.fromCodePoint(codePoint);
                if (!used.has(char)) { charset += char; used.add(char); }
            }
            
            document.getElementById('charset').value = charset;
            validateCharset();
        }

        function generateSuperCharset() {
            // ç®€åŒ–çš„å¤–æ˜Ÿæ–‡å­—ç¬¦é›†ç”Ÿæˆ
            let charset = '';
            const ranges = [[0x0A00, 0x0A7F], [0x0B00, 0x0B7F], [0x0C00, 0x0C7F], [0x0D00, 0x0D7F]];
            
            while (charset.length < 256) {
                const range = ranges[Math.floor(Math.random() * ranges.length)];
                const codePoint = Math.floor(Math.random() * (range[1] - range[0] + 1)) + range[0];
                const char = String.fromCodePoint(codePoint);
                if (!charset.includes(char) && codePoint > 0x0020) {
                    charset += char;
                }
            }
            
            document.getElementById('charset').value = charset;
            validateCharset();
            showMessage('å·²ç”Ÿæˆå¤–æ˜Ÿæ–‡å­—ç¬¦é›†ï¼', 'success');
        }

        function resetDefaultCharset() {
            const defaultCharset = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzçš„ä¸€æ˜¯åœ¨ä¸äº†æœ‰å’Œäººè¿™ä¸­å¤§ä¸ºä¸Šä¸ªå›½æˆ‘ä»¥è¦ä»–æ—¶æ¥ç”¨ä»¬ç”Ÿåˆ°ä½œåœ°äºå‡ºå°±åˆ†å¯¹æˆä¼šå¯ä¸»å‘å¹´åŠ¨åŒå·¥ä¹Ÿèƒ½ä¸‹è¿‡å­è¯´äº§ç§é¢è€Œæ–¹åå¤šå®šè¡Œå­¦æ³•æ‰€æ°‘å¾—ç»åä¸‰ä¹‹è¿›ç€ç­‰éƒ¨åº¦å®¶ç”µåŠ›é‡Œå¦‚æ°´åŒ–é«˜è‡ªäºŒç†èµ·å°ç‰©ç°å®åŠ é‡éƒ½ä¸¤ä½“åˆ¶æœºå½“ä½¿ç‚¹ä»ä¸šæœ¬å»æŠŠæ€§å¥½åº”å¼€å®ƒåˆè¿˜å› ç”±å…¶äº›ç„¶å‰å¤–å¤©æ”¿å››æ—¥é‚£ç¤¾ä¹‰äº‹å¹³å½¢ç›¸å…¨è¡¨é—´æ ·ä¸å…³å„é‡æ–°çº¿å†…æ•°æ­£å¿ƒåä½ æ˜çœ‹åŸåˆä¹ˆåˆ©æ¯”æˆ–ä½†è´¨æ°”ç¬¬å‘é“å‘½æ­¤å˜æ¡åªæ²¡ç»“è§£é—®æ„å»ºæœˆå…¬æ— ç³»å†›å¾ˆæƒ…è€…æœ€ç«‹ä»£æƒ³å·²é€šå¹¶æç›´é¢˜å…šç¨‹å±•äº”æœæ–™è±¡å‘˜é©ä½å…¥å¸¸æ–‡æ€»æ¬¡å“å¼æ´»è®¾åŠç®¡ç‰¹ä»¶é•¿æ±‚è€å¤´åŸºèµ„è¾¹æµè·¯çº§å°‘å›¾å±±ç»Ÿæ¥çŸ¥è¾ƒå°†ç»„è§è®¡åˆ«å¥¹æ‰‹è§’æœŸæ ¹è®ºè¿å†œæŒ‡å‡ ä¹åŒºå¼ºæ”¾å†³è¥¿è¢«å¹²åšå¿…æˆ˜å…ˆå›åˆ™ä»»å–æ®å¤„é˜Ÿå—ç»™è‰²å…‰é—¨å³ä¿æ²»åŒ—é€ ç™¾è§„çƒ­é¢†ä¸ƒæµ·å£ä¸œå¯¼å™¨å‹å¿—ä¸–é‡‘å¢äº‰æµé˜¶æ²¹æ€æœ¯æäº¤å—è”ä»€è®¤å…­å…±æƒæ”¶è¯æ”¹æ¸…å·±ç¾å†é‡‡è½¬æ›´å•é£åˆ‡æ‰“ç™½æ•™é€ŸèŠ±å¸¦å®‰åœºèº«è½¦ä¾‹çœŸåŠ¡å…·ä¸‡æ¯ç›®è‡³è¾¾èµ°ç§¯ç¤ºè®®å£°æŠ¥æ–—å®Œç±»å…«ç¦»ååç¡®æ‰ç§‘å¼ ä¿¡é©¬èŠ‚è¯ç±³æ•´ç©ºå…ƒå†µä»Šé›†æ¸©ä¼ åœŸè®¸æ­¥ç¾¤å¹¿çŸ³è®°éœ€æ®µç ”ç•Œæ‹‰æ—å¾‹å«ä¸”ç©¶è§‚è¶Šç»‡è£…å½±ç®—ä½æŒéŸ³ä¼—ä¹¦å¸ƒå¤å®¹å„¿é¡»é™…å•†ééªŒè¿æ–­æ·±éš¾è¿‘çŸ¿åƒå‘¨å§”ç´ æŠ€å¤‡åŠåŠé’çœåˆ—ä¹ å“çº¦æ”¯èˆ¬å²æ„ŸåŠ³ä¾¿å›¢å¾€é…¸å†å¸‚å…‹ä½•é™¤æ¶ˆæ„åºœç§°å¤ªå‡†ç²¾å€¼å·ç‡æ—ç»´åˆ’é€‰æ ‡å†™å­˜å€™æ¯›äº²å¿«æ•ˆæ–¯é™¢æŸ¥æ±Ÿå‹çœ¼ç‹æŒ‰æ ¼å…»æ˜“ç½®æ´¾å±‚ç‰‡å§‹å´ä¸“çŠ¶è‚²å‚äº¬è¯†é€‚å±åœ†åŒ…ç«ä½è°ƒæ»¡å¿å±€ç…§å‚çº¢ç»†å¼•å¬è¯¥é“ä»·ä¸¥ğŸ˜€ğŸ˜ƒğŸ˜„ğŸ˜ğŸ˜†ğŸ˜…ğŸ˜‚ğŸ¤£ğŸ˜ŠğŸ˜‡ğŸ™‚ğŸ™ƒğŸ˜‰ğŸ˜ŒğŸ˜ğŸ¥°ğŸ˜˜ğŸ˜—ğŸ˜™ğŸ˜šğŸ˜‹ğŸ˜›ğŸ˜ğŸ˜œğŸ¤ªğŸ¤¨ğŸ§ğŸ¤“ğŸ˜ğŸ¤©ğŸ¥³ğŸ˜ğŸ˜’ğŸ˜ğŸ˜”ğŸ˜ŸğŸ˜•ğŸ™â˜¹ï¸ğŸ˜£ğŸ˜–ğŸ˜«ğŸ˜©ğŸ¥ºğŸ˜¢ğŸ˜­ğŸ˜¤ğŸ˜ ğŸ˜¡ğŸ¤¬ğŸ¤¯ğŸ˜³ğŸ¥µğŸ¥¶ğŸ˜±ğŸ˜¨ğŸ˜°ğŸ˜¥ğŸ˜“ğŸ¤—ğŸ¤”ğŸ¤­ğŸ¤«ğŸ¤¥ğŸ˜¶ğŸ˜ğŸ˜‘ğŸ˜¬ğŸ™„ğŸ˜¯ğŸ˜¦ğŸ˜§ğŸ˜®ğŸ˜²ğŸ¥±ğŸ˜´ğŸ¤¤ğŸ˜ªğŸ˜µğŸ¤ğŸ¥´ğŸ¤¢ğŸ¤®ğŸ¤§ğŸ˜·ğŸ¤’ğŸ¤•ğŸ¤‘ğŸ¤ ğŸ˜ˆğŸ‘¿ğŸ‘¹ğŸ‘ºğŸ¤¡ğŸ’©ğŸ‘»ğŸ’€â˜ ï¸ğŸ‘½ğŸ‘¾ğŸ¤–ğŸƒğŸ˜ºğŸ˜¸ğŸ˜¹ğŸ˜»ğŸ˜¼ğŸ˜½ğŸ™€ğŸ˜¿ğŸ˜¾";
            document.getElementById('charset').value = defaultCharset.slice(0, 256);
            validateCharset();
        }

        // ç´¢å¼•ç ç›¸å…³å‡½æ•°
        function generateIndexCode() {
            const charset = document.getElementById('charset').value;
            const base64Charset = btoa(unescape(encodeURIComponent(charset)));
            const identifier = base64Charset.substring(0, 16);
            document.getElementById('indexCode').value = identifier;
            showMessage('å·²ç”Ÿæˆå­—ç¬¦é›†ç´¢å¼•ç ', 'success');
        }

        function copyIndexCode() {
            const indexCode = document.getElementById('indexCode');
            if (!indexCode.value) {
                showMessage('æ²¡æœ‰ç´¢å¼•ç å¯å¤åˆ¶', 'warning');
                return;
            }
            indexCode.select();
            document.execCommand('copy');
            showMessage('å·²å¤åˆ¶ç´¢å¼•ç åˆ°å‰ªè´´æ¿', 'success');
        }

        function applyIndexCode() {
            const indexCode = document.getElementById('indexCode').value;
            if (!indexCode) {
                showMessage('è¯·è¾“å…¥ç´¢å¼•ç ', 'warning');
                return;
            }
            const savedCharsets = JSON.parse(localStorage.getItem('savedCharsets') || '{}');
            if (savedCharsets[indexCode]) {
                document.getElementById('charset').value = savedCharsets[indexCode];
                validateCharset();
                showMessage('å·²åº”ç”¨å­—ç¬¦é›†', 'success');
            } else {
                showMessage('æœªæ‰¾åˆ°åŒ¹é…çš„å­—ç¬¦é›†', 'error');
            }
        }

        function saveIndexCodeToStorage() {
            const charset = document.getElementById('charset').value;
            const indexCode = document.getElementById('indexCode').value;
            if (!indexCode) {
                showMessage('è¯·å…ˆç”Ÿæˆç´¢å¼•ç ', 'warning');
                return;
            }
            const savedCharsets = JSON.parse(localStorage.getItem('savedCharsets') || '{}');
            savedCharsets[indexCode] = charset;
            localStorage.setItem('savedCharsets', JSON.stringify(savedCharsets));
            showMessage('å­—ç¬¦é›†å·²ä¿å­˜åˆ°æœ¬åœ°å­˜å‚¨', 'success');
        }

        function loadIndexCodeFromStorage() {
            const savedCharsets = JSON.parse(localStorage.getItem('savedCharsets') || '{}');
            const indexCodes = Object.keys(savedCharsets);
            if (indexCodes.length === 0) {
                showMessage('æœ¬åœ°å­˜å‚¨ä¸­æ²¡æœ‰ä¿å­˜çš„å­—ç¬¦é›†', 'warning');
                return;
            }
            const indexCodeList = indexCodes.map(code => `${code} (${savedCharsets[code].substring(0, 20)}...)`).join('\n');
            const selectedCode = prompt(`è¯·é€‰æ‹©è¦åŠ è½½çš„ç´¢å¼•ç :\n\n${indexCodeList}`, indexCodes[0]);
            if (selectedCode && savedCharsets[selectedCode]) {
                document.getElementById('charset').value = savedCharsets[selectedCode];
                document.getElementById('indexCode').value = selectedCode;
                validateCharset();
                showMessage('å·²åŠ è½½å­—ç¬¦é›†', 'success');
            }
        }

        // å…¶ä»–åŠŸèƒ½
        function copyToClipboard() {
            const outputText = document.getElementById('outputText');
            if (!outputText.value) {
                showMessage('æ²¡æœ‰å†…å®¹å¯å¤åˆ¶', 'warning');
                return;
            }
            outputText.select();
            document.execCommand('copy');
            showMessage('å·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
        }

        function clearAll() {
            document.getElementById('inputText').value = '';
            document.getElementById('outputText').value = '';
            document.getElementById('key').value = '';
            updateStats();
            showMessage('å·²æ¸…ç©ºæ‰€æœ‰å†…å®¹', 'info');
        }

        function decryptWithoutKey() {
            showMessage('æ­¤åŠŸèƒ½å·²æ•´åˆåˆ°ä¸‡èƒ½è§£å¯†æ¨¡å¼ä¸­', 'info');
        }

        function enableBackdoor() {
            showMessage('ç³»ç»Ÿåé—¨å·²é»˜è®¤å¯ç”¨', 'success');
            localStorage.setItem('dev_backdoor_enabled', 'true');
        }

        function showDevInfo() {
            const info = `
å¼€å‘è€…ç³»ç»Ÿä¿¡æ¯ï¼š
- ç‰ˆæœ¬: 4.0.0 (æœ€é«˜é˜²å¾¡çº§åˆ«)
- åŠ å¯†ç®—æ³•: å¢å¼ºå¼‚æˆ– + è‡ªå®šä¹‰å­—ç¬¦é›†ç¼–ç 
- éšè—ç­–ç•¥: 4ç§åŠ¨æ€é€‰æ‹©
- æ”¯æŒå­—ç¬¦: å…¨Unicodeå­—ç¬¦é›†
- åŠ å¯†æ¨¡å¼: æ™®é€šåŠ å¯† + è¶…çº§åŠ å¯† + ä¸‡èƒ½è§£å¯†
- é˜²å¾¡çº§åˆ«: ä¼ä¸šçº§
- åé—¨çŠ¶æ€: å·²å¯ç”¨
- æ—¶é—´æˆ³: ${new Date().toISOString()}
            `.trim();
            alert(info);
        }
    </script>
</body>
</html>
